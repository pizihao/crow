###  开发日志 0.0.7

==2022年6月2日19:28:49==

​	针对类型填充的运行速度，添加测试后发现其并不理想。虽然达到了类型填充的目的，但是仅适用于小量的数据，当数据量变大时其运行时间呈指数级上升。

其中存在两个可以控制的量：

- 单个属性序列化的大小，如果是一个集合类型，那么该集合的size就是大小。
- 塞入属性的方式。

#### 问题一

##### 解决方案

> 解决方案1：多线程方案

​	在类型填充时通过多个线程去执行，但是并行化类型填充需要有非常强的顺序性，在多线程执行时这个顺序会被打乱，顾此方案不行

> 解决方案2：减少size

​	通过测试发现，序列化的size达到某种大小时才会出现转化缓慢的情况，即针对java中的Iterable及其子类的实现，在可以获取到泛型元素的情况下，仅通过第一个元素的取值。可行

##### 说明

​	通过添加类型压缩器的方法解决了问题一，通过类型压缩器可以大大减少大型的集合类型的序列化问题，同时提供了可供拓展的抽象用于实现其他的可迭代类型。

​	对象压缩器的主旨是：用部分代表整体，即将一个大的对象压缩成小的对象，并且小对象可以兼容大对象的类型。

​	这里举个例子说明一下：比如我存在一个链表类型 --> linkedList，存在一些数据，如下图所示：

~~~mermaid
graph LR
	A((A)) --> B((B)) --> C((C)) --> D((...))  --> X((X))  
~~~

​	这是一个数据量非常大的对象，如果直接对其序列化，则会非常耗时，因为在java中存在泛型的概念，泛型可以固定链表中每个元素的类型，这样就可以通过压缩的方式将其转化成一个小的对象，如下图所示：

~~~mermaid
graph LR
A((A))
~~~

​	序列化一个只有一个元素的链表和序列化大量元素的链表在结果上一样的，但是其性能却差距相当大。

对象压缩器就是按照这一原理进行设计 -- 用部分代表整体

==2022年6月7日10:22:04==

#### 问题二

##### 问题引入

​	针对一个对象，在写入其中的属性时通常会使用反射的方式，此处的反射有两种做法：

1. 通过反射得到其属性，直接修改属性的值
2. 通过反射得到该属性的setter方法，通过调用方法 修改属性的值

​	两种方式效率相差无几，当前版本中使用的是第一种方式，这会导致一个问题，因为反射的性能较低，所以当面对大批量的数据需要进行处理时，其表现较差。

##### 解决方案

> 解决方案1

​	因为验证类型是通过序列化的方式解决的，所以写入数据也可以通过序列化来解决，将一个json串反序列化就可以得到真正需要的对象，可行。

> 解决方案2

​	经测试发现，相对于序列化的过程来说，反射消耗的时间可以忽略不计，问题一解决的只有属对象属性可以压缩的情况，所以当需要填充的对象属于可压缩时是否也可以这样解决。答案是可行的，但具体的施行并不相同，其更类似于批量处理。可行

##### 说明

​	最终选择了方案2进行解决，方案1会在未来的版本以独立的功能进行实现。

